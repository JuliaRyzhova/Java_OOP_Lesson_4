Задача реализовать свой LinkedList с некоторыми методами, например:
* вставки в начало, 
* вставки конец списка, 
* вставки по индексу,
* удаления по индексу,
* получения элемента по индексу.

Класс LInkedList имплементируется от 2 интерфейсов Java:
1. List
2. Deque

и значит, что он принимает в себя все его методы. 
Это обеспечивает возможность создания двунаправленной очереди из любых
(в том числе и null) элементов. Каждый объект, помещенный в связанный 
список, является узлом (нодом). Каждый узел содержит элемент, ссылку на 
предыдущий и следующий узел. Фактически связанный список состоит из 
последовательности узлов, каждый из которых предназначен для хранения 
объекта определенного при создании типа.

Для начала создадим оба интерфейса и пропишем в них основные методы, которые по контракту 
перетекут в наш LinkedList.

```
    public interface GBList<T> extends Iterable<T>{
    boolean add(T type);
    void remove(int index);
    T get(int index);
    int size();
}
```
И 

```
    public interface GBDeque<T> extends Iterable<T> {
    boolean addFirst(T type);
    boolean addLast(T type);
    public Iterator<T> descendingIterator();
    }
```

Теперь приступим к реализации. Создаем класс GBLinkedList и имплементриуем ему 
наши интерфесы.

```
    public class GBLinkedList<T> implements GBList<T>, GBDeque<T> 
```

Добавим поля класса: размер списка и указатели на первую и последнюю ноду.
(модификатор transient указывает на то, что данное свойство класса нельзя
сериализировать) P.s. в качестве модификатора доступа можно указать private, но тогда нужно будет прописать геттеры и сэттеры.

```
    transient int size = 0;
    transient Node<T> first;
    transient Node<T> last;
```

В рамках нашего класса нам понадобится вспомогательный приватный Класс Node, вложенный в GBLinkedList.
Он хранит в себе текущий элемент и ссылки на предыдущий и следующий элементы.

```
    private static class Node<T> {
        T currentEl;
        Node<T> next;
        Node<T> prev;

        Node(Node<T> prev, T currentEl, Node<T> next) {
            this.currentEl = currentEl;
            this.next = next;
            this.prev = prev;
        }
    }
```

При каждом добавлении объекта в список создается один новый узел, а также изменяются значения полей связанного 
списка (size, first, last) в классе BGLinkedList.
От интерфейса Deque мы должны выполнить контракт по реализации методов:
* boolean addFirst(T type) - добавление эл-та в начало списка
* boolean addLast(T type) - добавление эл-та в конец списка

Рассмотрим, чтоже происходит под капотом первого.
Добавляя новый элемент в начало списка - нам нужно объявить временную переменную типа Node<T> и присвоить ей указатель
первую ноду(т.е. ссылку на предыдущий элемент, на null).
Далее создаем новый узел(ноду) где ссылка на предыдущий элемент -это null, текущему элементу присваиваем значение объекта,
который к нам поступил (type, т.е. элемент, который мы вставляем в список), а ссылке на следующий элемент присваиваем 
значение переменной temp.

Если ссылка на предыдущий элемент в рамках нашего списка - пустая(null), то указателю на последнюю ноду 
присваиваем значение созданной выше ноды. В ином случае значение созданной ноды присваиваем ссылке на предыдущий элемент.
Увеличим размер списка на 1.

```
        @Override
    public boolean addFirst(T type) {
        try {
            final Node<T> temp = first;
            final Node<T> newNode = new Node<>(null, type, temp);
            first = newNode;
            if (temp == null)
                last = newNode;
            else
                temp.prev = newNode;
            size++;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }
```
Если наш список изначально пуст, то при добавлении нового элемента нода хранит в себе значение этого элемента,
а ссылки на предыдущий и следующий элементы равны null.

Рассмотрим метод добавления элемента в конец списка. Он аналогичен методу добавления в начало, просто все 
то же самое мы проделываем с обратной стороны нашего списка.
Временной переменной типа Node<T> мы присваиваем указатель на последний элемент. 
Создаем новую ноду, обновляем значения предыдущей ссылки, текущего элемента и ссылки на следующий элемент.
Увеличиваем размер списка на 1.

```
    @Override
    public boolean addLast(T type) {
        try {
            final Node<T> temp = last;
            final Node<T> newNode = new Node<>(temp, type, null);
            last = newNode;
            if (temp == null)
                first = newNode;
            else
                temp.next = newNode;
            size++;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }
```

Помимо вставки в начало или конец списка, мы можем вставить элемент по индексу.
За добавление элемента в конкретную ячейку по индексу отвечает метод add():

```
        public void add(int index, T type) {
            if (index == size) addLast(type);
            else addBefore(type, node(index));
        }
```
Добавление происходит в несколько этапов. Для этого нам нужны вспомогательные методы:
1. Мы проверяем на то, что индекс, по которому происходит вставка, не выходит за границы списка:

```
        private void checkPositionIndex(int index) {
            if (!(index >= 0 && index <= size))
                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

```
Метод checkPositionIndex() на вход получает индекс, по которому мы хотим вставить элемент. Проверяет, является ли
индекс большем или равным 0 и одновременно меньшем или равным размеру нашего списка. 
Если нет, то сработает исключение, и с помощью отдельного метода сообщит нам об ошибке.

```
        private String outOfBoundsMsg(int index) {
            return "Index: " + index + ", Size: " + size;
    }
```

2. Вернемся к нашему методу add(). Итак, мы проверили корректность индекса. 
И если индекс равен размеру нашего списка, то по сути мы хотим вставить элемент в конец списка. А за это у нас 
уже создан метод addLast(), поэтому мы смело его вызовем.
В ином случае, нам потребуется написать отдельные методы для вставки в середину списка addBefore() и node().

Метод node() принимает в качестве аргумента индекс, по которому мы хотим вставить элемент и 
возвращает (ненулевой) узел с указанным индексом элемента.
```
    Node<T> node(int index) {
        if (index < (size - 1)) {
            Node<T> x = first;
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else {
            Node<T> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.prev;
            return x;
        }
    }
```
После того как найден элемент, перед которым будет вставлен новый элемент, вызывается addBefore()
Как происходит добавление по индексу? Сначала находим место вставки, отсчитав от начала необходимое количество звеньев,
после чего делаем новое звено и скрепляем его в месте цепи, которое только что нашли.
Не забудем увеличить размер нашего списка.


```
    private void addBefore(T type, Node<T> succ) {
        Node<T> pred = succ.prev;
        Node<T> newNode = new Node<>(pred, type, succ);
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
    }
```

Рассмотрим метод удаления по индексу remove()

```
   @Override
    public void remove(int index) {
           checkPositionIndex(index);
           unlink(node(index));
    }
```
Удаление по индексу происходит в несколько этапов:
1. Проверяем на то, что индекс, по которому происходит вставка, не выходит за границы списка. Для
этого у нас уже есть метод checkPositionIndex().
2. После этого находится удаляемый элемент с помощью уже знакомого метода node().
3. Далее, в зависимости от расположения элемента, идет 'разлинковка', т.е перебрасывание ссылок,
в методе unlink(), который принимает в качестве параметра ноду искомого элемента.

```
    T unlink(Node<T> x) {
        final T element = x.currentEl;
        final Node<T> next = x.next;
        final Node<T> prev = x.prev;

        if (prev == null) {
            first = next;
        } else {
            prev.next = next;
            x.prev = null;
        }

        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
            x.next = null;
        }

        x.currentEl = null;
        size--;
        return element;
    }
```
Метод получения значения по индексу get().
Проверяем корректность индекса, т.е. находится ли он в пределах нашего списка и через метод node() возвращаем
значение необходимого элемента.

```
    @Override
    public T get(int index) {
        checkPositionIndex(index);
        return node(index).currentEl;
    }
```

